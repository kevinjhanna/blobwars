\documentclass[10pt,a4paper,notitlepage,twocolumn,draft]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{authblk}
\usepackage{makeidx}

\usepackage[utf8]{inputenc}
\renewcommand\Authand{ y }
\author[1]{\rm Kevin J. Hanna}
\author[2]{\rm Pablo A. Costesich}
\affil[ ]{Alumnos de Ingeniería Informática}
\affil[ ]{Instituto Tecnológico de Buenos Aires}
\affil[ ]{Av. Madero 399, C.A.B.A., Argentina}
\affil[1]{\textit {khanna@alu.itba.edu.ar}}
\affil[2]{\textit {pcostesi@ieee.org}}


\newenvironment{definition}[1][Definición]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}


%\email{khanna@alu.itba.edu.ar, pcostesi@ieee.org}

\title{Estrategia de resolución Minimax para Juegos de Suma Cero e Implementación para el juego \textit {BlobWars}}
\makeindex

\begin{document}
\maketitle
\begin{abstract}
Se presenta una introducción a la Teoría de Juegos y Juegos de Suma Cero. Éstos son juegos de dos jugadores con turnos y un balance entre sus ganancias y pérdidas. La estrategia de resolución analizada en este informe es Minimax, un algoritmo de búsqueda en profundidad limitada, junto con la heurística de Poda Alfa-Beta. Se detalla la implementación y resultados prácticos.
\end{abstract}

\section{Introducción}
El Trabajo Práctico Especial de la cátedra de Estructuras de Datos y Algoritmos para el segundo cuatrimestre de 2012 propone la resolución del juego \textit{BlobWars} mediante el algoritmo Minimax, con y sin Poda Alfa-Beta, en el lenguaje de programación Java. La implementación del mismo debe contar con un modo visual y de lectura de tableros por archivo.


\subsection{BlobWars}
\textit{BlobWars} es un juego de dos jugadores por turnos en un tablero de 8x8. El objetivo es lograr la mayor cantidad de piezas sobre el tablero para cuando alguno de los jugadores no pueda realizar nuevos movimientos.

Los posibles movimientos de una mancha (\textit{blob}) son siempre hacia casilleros vacíos y cumplen estas reglas:
\begin{itemize}
\item Los movimientos a distancia 1 mantienen la mancha de origen y generan una nueva del mismo color en el casillero de destino.
\item Los movimientos a distancia 2 desplazan la mancha al casillero de destino.
\item No pueden realizarse movimientos que no sean de distancia 1 o 2.
\end{itemize}

\begin{definition}
El conjunto $Manchas$ es equivalente a $\{-1, 0, 1\}$.
\end{definition}

\begin{definition}Un tablero es una matriz de $Manchas^{8x8}$.\end{definition}

\begin{definition}
Un punto es un par ordenado $\left\langle x, y\right\rangle \in Point$, donde $Point = Side \times Side$ y $Side = \{1, 2, 3, 4, 5, 6, 7, 8\}$.
\end{definition}

\begin{definition}
Se llama $Movements$ al siguiente conjunto:
\begin{equation}
Movements = Point \times Point
\end{equation}
\end{definition}

\begin{definition}
Un movimiento es un par ordenado $\left\langle inicio, destino\right\rangle \in Movements$.

Notación: $inicio \rightarrow destino$.
\end{definition}

\begin{definition}
Un movimiento válido para un jugador $p$ es un movimiento tal que el casillero de destino $d$ se encuentra libre (su valor es $0$) y el de inicio $s$ pertenece al jugador $p$ (su valor es $p$).

Notación: $v_{s \rightarrow d}$
\end{definition}

\begin{definition}
Un casillero es el valor del tablero en un punto $p$.
\end{definition}

\begin{definition}
El casillero vacío es equivalente al valor $0$ en el tablero para el punto $p$.
\end{definition}

\begin{definition}
Una mancha es uno de los tres posibles estados $\in Manchas$ de una celda en un punto del tablero:
\begin{itemize}
\item[-1] \emph{Humano}: representado por la letra \textit{H}.
\item[0] \emph{Vacío}: representado por el espacio en blanco.
\item[1] \emph{Computadora}: representado por la letra \textit{C}.
\end{itemize}
\end{definition}

\begin{definition}
Se define distancia como:
\begin{equation}
    distancia(a, b) = \max(|a[x] - b[x]|, |a[y] - b[y]|)
\end{equation}

Donde $a$ y $b$ son los puntos en cuestión (tuplas de dos componentes $\mathbb{N}_{0}$), y $a[x]$ significa la componente $x$ de $a$.
\end{definition}

Adicionalmente, al final de cada movimiento la mancha en el destino \textit{infecta} a las vecinas según estas reglas:
\begin{itemize}
\item Si el casillero no se encuentra ocupado entonces se deja libre (no se altera).
\item Si el casillero se encuentra ocupado, la mancha presente en éste cambia al color de la mancha que infecta.
\end{itemize}

\begin{definition}
Aplicar un movimiento $m$ para un jugador $p$ a un tablero $b$ es aplicar las reglas de movimiento seguido de \textit{infectar} el casillero de destino. Se obtiene como resultado un tablero $b'$
\end{definition}

\begin{definition}
Un \textit{Tablero Terminal} es un tablero tal que para algún jugador no existen movimientos válidos para ninguna de sus manchas.
\begin{equation}
terminal(b) \Leftrightarrow \nexists m \in v_{s \rightarrow d}(p) \forall s, d \in Movements
\end{equation}
Donde $b$ es el tablero, $m$ un movimiento válido, $p$ un jugador y $x$ un punto.
\end{definition}

El juego termina cuando el tablero se completa o cuando el siguiente jugador no puede realizar un movimiento válido. Vale destacar que la primera condición implica la segunda.

\begin{definition}
Un turno es aplicar un movimiento válido $m$ para un jugador $p$ a un tablero $b$ y retornar el tablero resultante $b'$:
\begin{equation}
b' = turno(b, p, m)
\end{equation}
\end{definition}

\begin{definition}
Un \textit{ply} es un grupo de dos turnos que resulta de la aplicación recursiva de éstos para dos movimientos de jugadores alternados $m_p$ y $m'_{p'}$. En otras palabras: 
\begin{equation}
ply(b, m_p, m_{p'}) = turno(turno(b, p, m_p), p', m_{p'})
\end{equation}
\end{definition}

\begin{definition}
Una partida es una serie finita $G$ de $n$ \textit{plies} tal que aplicar el último movimiento ($m^{n}_{s \rightarrow p}$) al tablero $b^{n - 1}$ resulta en un tablero terminal $b^{n}$; siendo $b^{n}$ el único tablero terminal en $G$.
\end{definition}

\section{Teoría de Juegos}
\subsection{Juegos de Suma Cero}
\section{Estructuras de Datos}
\section{Algoritmos}
\subsection{Minimax (Na\"ive)}
\subsection{Minimax con Poda Alfa-Beta}
\section{Problemas encontrados}
\subsection{Uso eficiente de memoria}
  Inicialmente cuando se desarrollaron las clases del juego, se notó que consumían memoria demás.
  Eso se vió demostrado ya que el algoritmo propuesto para minimax no podía llegar hasta el nivel 5.
  A continuación se detallan los puntos críticos en donde se tuvo que repensar la implementación.

  \subsection{Clase Board}
    En un principio, la forma utilizada para representar el board fue utilizando objetos Tile, del cual heredaban EmptyTile y BlobTile.
    Es decir, que la cantidad de referencias de cada tablero era siempre de 64 $(8 * 8)$.  A la vez, cada BlobTile contenía una referencia a un Player.

    Para iterar facilmente por los tiles de un Player y obtener sus jugadas posibles se contó con un $HashMap<Player, ArrayList<Point>>$, y un método para acceder a esos  puntos en donde se encontraban los tiles de cada jugador.

    Para hacer uso más eficiente de la memoria, se decidió implementar el Board cómo un array primitivo de Player, y un método para convertir de Point al indice de ese array.
    En este caso se hizo un cambio que consume menos memoria al haber menos referencias y objetos en tiempo de ejecucón, aunque es cierto que esa solución hace que haya que calcular más en tiempo de ejecución.

    El cambio más radical en cuanto a cantidad de memoria consumida, se logró implementando un iterador de Board para ser utilizado al generar los tableros con
    las jugadas posibles a partir de cierto Board.

\section{Comparaciones y pruebas}
\section{Implementación}
\section{Conclusiones}
\section{Anexo}
\subsection{Implementación alternativa del núcleo del Solver}
\begin{thebibliography}{9}
  % type bibliography here
  \bibitem[Doe]{doe} text goes here
\end{thebibliography}
\end{document}
